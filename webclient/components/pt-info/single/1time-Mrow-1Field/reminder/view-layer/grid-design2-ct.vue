<!-- Reference implementation -->
<template>
  <el-card
    shadow="hover"
    class="box-card sc-reminder-all-content"
    :style="cfGetVariablesFromClientSideTableToUseInCSS"
  >
    <div class="sc-reminder-all-content-header clearfix" slot="header">
      <span>Reminders</span>
      <el-button-group style="float: right; display: none">
        <el-button
          style="padding: 3px; color: #c0c4cc; border: none"
          plain
          tabindex="-1"
          @click="mxOpenACtInCl"
          class="el-icon-circle-plus-outline"
        ></el-button>
        <el-button
          style="padding: 3px; color: #c0c4cc; border: none"
          plain
          tabindex="-1"
          class="el-icon-s-grid"
          @click="mxOpenMCtInCl"
        ></el-button>
        <el-button
          style="padding: 3px; color: #c0c4cc; border: none"
          plain
          tabindex="-1"
          @click="mxOpenDDialog"
          class="el-icon-document-delete"
        ></el-button>
        <el-button
          style="padding: 3px; color: #c0c4cc; border: none"
          plain
          tabindex="-1"
          @click="mxOpenXCtInCl"
          class="el-icon-delete"
        ></el-button>
      </el-button-group>
    </div>
    <div class="sc-reminder-all-content-body">
      <el-card
        v-for="rem in cfArOfRemForDisplayInTable"
        :key="rem.id"
        class="box-card sc-reminder-individual-card"
        shadow="hover"
        :style="mfGetCssClassName(rem)"
      >
        <div
          v-if="rem.vnRowStateInSession === 9"
          class="sc-reminder-individual-socket-messege-container"
        >
          <span>Added from socket</span>
        </div>
        <el-button-group style="float: right; display: none">
          <el-tooltip class="item" effect="dark" content="Click to edit" placement="top-start">
            <el-button
              class="el-icon-edit"
              style="padding: 3px; color: #c0c4cc; border: none"
              plain
              tabindex="-1"
              @click="mxOpenCCtInCl(rem.clientSideUniqRowId)"
            ></el-button>
          </el-tooltip>

          <el-tooltip class="item" effect="dark" content="Info" placement="top-start">
            <el-button
              class="el-icon-discover"
              style="padding: 3px; color: #c0c4cc; border: none"
              plain
              tabindex="-1"
            ></el-button>
          </el-tooltip>

          <el-tooltip class="item" effect="dark" content="Click to delete" placement="top-start">
            <el-button
              class="el-icon-circle-close"
              style="padding: 3px; color: #c0c4cc; border: none"
              plain
              tabindex="-1"
              @click="mxOpenDPrompt(rem.clientSideUniqRowId)"
            ></el-button>
          </el-tooltip>
        </el-button-group>

        <!-- <el-button type="text">{{ rem.description }}</el-button> 
          if I use the button then a long text is not getting divided into multiple lines

          if rowStateInThisSession == 9 then the div should have a orange border
          Why we are doing this?
            Doctor is sitting infront of computer suddenly a new Rem appears. That is a confusing event.
            Instead if the new Rem that came on screen gets a orange border with top right corner saying "New rem added from socket" that is much better UX.
        -->
        <div
          class="text item sc-reminder-individual-card-content"
          @click="mxOpenCCtInCl(rem.clientSideUniqRowId)"
        >
          <!-- <div v-if="rem.vnRowStateInSession === 9">Added from socket {{ rem.description }}</div> -->
          <div>{{ rem.description }}</div>
        </div>
      </el-card>
    </div>

    <el-pagination
      :hide-on-single-page="true"
      background
      layout="pager"
      :total="cfLengthOfDataArray"
      @current-change="mfTablePageChanged"
    ></el-pagination>
    <ctActOnSocketMessages></ctActOnSocketMessages>
  </el-card>
</template>

<script>
import mxFullSyncWithDbServer from '../db/full-sync-with-server-db-mixin'
import clientSideTable from '../db/client-side/structure/rem-table.js'
import ctActOnSocketMessages from '../change-layer/act-on-socket-messages-from-server-ct.vue'
import clInvokeMixin from './cl-invoke-mixin.js'
import objCommonOrm from '@/components/pt-info/single/1time-1row-mField/common-for-all-components/db/client-side/structure/table.js'

export default {
  components: { ctActOnSocketMessages },
  mixins: [clInvokeMixin, mxFullSyncWithDbServer],
  data() {
    return {
      tablePageNumber: 1,
      daRowStatesNotHavingCD: [2, 24, 2456, 2457, 24578], // Set of array of 'vnRowStateInSession' should not have change and delete button. As per GLOSSARY.md C stands for 'change' and D stands for 'delete'.
      daSelectedRemForDelete: [],
    }
  },
  computed: {
    cfGetVariablesFromClientSideTableToUseInCSS() {
      const objCommonRow = objCommonOrm.find(1) // if this is async then it does not work.
      if (objCommonRow !== null) {
        let fontSizeOfContentEveryWhere = objCommonRow.fontSizeOfContentEveryWhereForNormalEyeSight
        if (objCommonRow.currentUserEyeSight == 'weak') {
          fontSizeOfContentEveryWhere = objCommonRow.fontSizeOfContentEveryWhereForWeakEyeSight
        }
        return {
          '--font-size-of-content-every-where': fontSizeOfContentEveryWhere,
        }
      }
    },
    cfLengthOfDataArray() {
      const arFromClientSideTable = clientSideTable.fnGetValidUniqueUuidRows()
      return arFromClientSideTable.length
    },

    cfArOfRemForDisplayInTable() {
      // Whenever clientSideTable will change this will get called. Even when there are 100 rows in the table when clientSideTable rem changes this gets called once'
      const arFromClientSideTable = clientSideTable.fnGetValidUniqueUuidNotEmptyRows('description')
      /*  Q) Should this function return the array it gets from ORM or modify the array?
              Option1: Return ORM array
                  -ves:
                    1. Created at needs to be made inside the template
                    2. Making pager would be harder
                  +ves:
                    No need to run the for loop
      */
      const arRemsForDisplay = []
      let obj = {}
      if (arFromClientSideTable.length) {
        let date = ''
        const startDataRowInidex = (this.tablePageNumber - 1) * 10
        const endDataRowIndex = startDataRowInidex + 10
        for (
          let i = startDataRowInidex;
          i < arFromClientSideTable.length && i < endDataRowIndex;
          i++
        ) {
          obj = {}
          obj.description = arFromClientSideTable[i].description
          // For date format ref: /cts/pt-info/single/1time-Mrow-1Field/reminder/view-layer/timeline-ct.vue:53
          date = new Date(arFromClientSideTable[i].ROW_START * 1000)
          obj.createdAt =
            date.toLocaleString('default', { month: 'long' }) +
            '-' +
            date.getDate() +
            '-' +
            date.getFullYear()
          obj.ROW_START = date.toLocaleString()
          obj.ROW_END = new Date(arFromClientSideTable[i].ROW_END * 1000).toLocaleString()
          obj.vnRowStateInSession = arFromClientSideTable[i].vnRowStateInSession
          obj.uuid = arFromClientSideTable[i].serverSideRowUuid
          obj.$id = arFromClientSideTable[i].$id
          obj.clientSideUniqRowId = arFromClientSideTable[i].clientSideUniqRowId
          arRemsForDisplay.push(obj)
        }
      }
      return arRemsForDisplay
    },
  },
  async mounted() {
    if (clientSideTable.query().count() > 0) {
    } else {
      await this.mxGetDataFromDb()
    }
  },
  methods: {
    mfTablePageChanged(pNewPageNumber) {
      this.tablePageNumber = pNewPageNumber
    },
    mfHandleSelectionForDelete(val) {
      this.daSelectedRemForDelete = val
    },
    // This is used to make the rows that are in change state a orange background.
    mfGetCssClassName(pRow) {
      const strOfNumber = pRow.vnRowStateInSession.toString()
      const lastCharecter = strOfNumber.slice(-1)
      if (lastCharecter === '4' || lastCharecter === '6') {
        return 'color: #E6A23C;'
      }
       else if(lastCharecter === '9') { // when data added from socket overwrite default design
        return 'border:1px solid #ff9900;color: #ff9900;'
      }
      else{
        return 'color: #202020;'
      }
    },
  },
}
</script>

<style>
/* Generation ->
==============
                                       .sc-reminder-all-content
 Generation 1                                      |
==============                     _________________________________
                                  |                                |
                    .sc-reminder-all-content-header                |
 Generatiobn 2                                                     |
                                    _______________________________|
                                  |
                  .sc-reminder-all-content-body
==============                    |
                                  |
                   .sc-reminder-individual-card
Generatiobn 3                     |
                       ________________________________________________________________________________
                      |                                 |                                             |
        .sc-reminder-individual-card-content    .sc-reminder-individual-card-info-icon           .sc-reminder-individual-card-delete-icon

==============
*/

/* Generation Level 1 */
.sc-reminder-all-content .el-card__header {
  /* Goal: Manage Distance from border to content in header*/
  padding: 10px !important;
}

.sc-reminder-all-content .el-card__body {
  /* Goal: Manage  Distance from border to content in body*/
  padding: 10px !important;
}

/* Generation Level 2 / Child 1 == Goal: Header icon management */

/* When anywhere inside the card make the action icons in the card header -> level 1 visual */
.el-card:hover .sc-reminder-all-content-header .el-button-group {
  display: inline-block !important;
}

/* When inside the card header make the action icons in the card header -> level 2 visual */
.el-card__header:hover .sc-reminder-all-content-header .el-icon-circle-plus-outline {
  color: #67c23a !important;
  font-size: 1.5rem;
}
.el-card__header:hover .sc-reminder-all-content-header .el-icon-s-grid {
  color: #409eff !important;
}

.el-icon-s-grid:hover {
  font-size: 1.5rem;
}

.el-card__header:hover .sc-reminder-all-content-header .el-icon-document-delete {
  color: #f56c6c !important;
}

.el-icon-document-delete:hover {
  font-size: 1.5rem;
}

.el-card__header:hover .sc-reminder-all-content-header .el-icon-delete {
  color: #909399 !important;
}
.el-icon-delete:hover {
  font-size: 1.5rem;
}

/* Generation Level 2 / Child 2 */

/* Goal: When less space display 1 card in a row. When more space display 100 cards in a row. */
.sc-reminder-all-content-body {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  /* Some other grid-template-columns options are :
  grid-template-columns: repeat(auto-fit, minmax(32rem, 1fr));
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  grid-template-columns: repeat(auto-fit, max(200px)); compared to minmax(200px, 1fr) there is more magin between cols and less content fits.
  */
  grid-gap: 1px;
  grid-auto-flow: row; /* This is default value */
  margin: 1px;
}

/* Generation Level 3 */

/* Goal: Margin and padding of individual card */

.sc-reminder-individual-card {
  cursor: pointer;
  overflow-wrap: break-word;
  position: relative;
  margin: 1px;
  padding: 10px 1px 1px !important;
  /* Goal: Give normal and weak eyesight two different font size*/
  font-size: var(--font-size-of-content-every-where);
  overflow: visible !important;
}

/* Goal: Design for socket messege container */
.sc-reminder-individual-socket-messege-container {
  font-size: 10px;
  color: #ff9900;
  position: absolute;
  font-weight: bolder;
  padding: 0 1px;
  top: -7px;
  left: 30%;
  background-color: #fff;
}

/* Goal: Header icon management  */
.el-card:hover .sc-reminder-individual-card .el-button-group {
  display: inline-block !important;
  position: absolute;
  top: 0px;
  right: 0px;
}

.sc-reminder-individual-card:hover .el-icon-edit {
  color: #67c23a !important;
  font-size: 1.5rem;
}

.sc-reminder-individual-card:hover .sc-reminder-individual-card-content {
  color: #67c23a !important;
}

.sc-reminder-individual-card:hover .el-icon-discover {
  color: #909399 !important;
}

.el-icon-discover:hover {
  font-size: 1.5rem;
}

.el-icon-discover:hover .sc-reminder-individual-card-content {
  color: #909399 !important;
}

.sc-reminder-individual-card:hover .el-icon-circle-close {
  color: #f56c6c !important;
}

.el-icon-circle-close:hover {
  font-size: 1.5rem;
}

/* Goal: For subtle tooltip */
.el-tooltip__popper {
  padding: 5px;
}
</style>


